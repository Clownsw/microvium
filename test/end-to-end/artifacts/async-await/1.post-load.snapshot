export 0 = &function run;

slot ['global:assertEqual'] = host function 3;
slot ['global:asyncTestComplete'] = host function 6;
slot ['global:print'] = host function 1;
slot runAsync = &function runAsync;
slot test_asyncFunctionArguments = &function test_asyncFunctionArguments;
slot test_asyncInExpression = &function test_asyncInExpression;
slot test_asyncThisArgument = &function test_asyncThisArgument;
slot test_asyncVariablesFromNested = &function test_asyncVariablesFromNested;
slot test_awaitReturnValue = &function test_awaitReturnValue;
slot test_minimal = &function test_minimal;

function Array_push() {
  entry:
    LoadArg(index 1);
    LoadArg(index 0);
    LoadArg(index 0);
    Literal(lit 'length');
    ObjectGet();
    LoadVar(index 0);
    ObjectSet();
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['Async catch block']() {
  entry:
    ScopePush(count 4);
    StoreScoped(index 2);
    Literal(lit &function asyncComplete);
    StoreScoped(index 0);
    Literal(lit false);
    StoreScoped(index 1);
    EnqueueJob();
    ScopePop();
    Return();
}

function asyncComplete() {
  entry:
    LoadScoped(index 5);
    Literal(lit undefined);
    LoadScoped(index 1);
    LoadScoped(index 2);
    Call(count 3, flag false);
    Return();
}

function asyncFunction() {
  entry:
    AsyncStart(count 4, flag false);
    LoadArg(index 0);
    StoreScoped(index 2);
    LoadArg(index 1);
    StoreScoped(index 3);
    LoadScoped(index 3);
    Literal(lit 1);
    BinOp(op '+');
    AsyncReturn();
}

function asyncHostCallback() {
  entry:
    ScopePush(count 4);
    LoadArg(index 2);
    StoreScoped(index 2);
    Literal(lit &function asyncComplete);
    StoreScoped(index 0);
    LoadArg(index 1);
    Branch(@success, @fail);
  fail:
    Literal(lit false);
    Jump(@final);
  final:
    StoreScoped(index 1);
    EnqueueJob();
    ScopePop();
    Literal(lit no-op-function);
    StoreScoped(index 0);
    Literal(lit undefined);
    Return();
  success:
    Literal(lit true);
    Jump(@final);
}

function myAsyncFunc() {
  entry:
    AsyncStart(count 3, flag false);
    LoadArg(index 0);
    StoreScoped(index 2);
    LoadGlobal(name 'global:print');
    Literal(lit undefined);
    Literal(lit 'Inside async function');
    Call(count 2, flag true);
    Literal(lit undefined);
    AsyncReturn();
}

function nested2() {
  entry:
    AsyncStart(count 4, flag true);
    LoadArg(index 0);
    StoreScoped(index 2);
    LoadScoped(index 15);
    Literal(lit 19);
    BinOp(op '*');
    LoadVar(index 3);
    StoreScoped(index 15);
    Pop(count 1);
    Literal(lit undefined);
    AsyncReturn();
}

function nestedFunc() {
  entry:
    AsyncStart(count 4, flag true);
    LoadArg(index 0);
    StoreScoped(index 2);
    LoadScoped(index 15);
    Literal(lit 13);
    BinOp(op '*');
    LoadVar(index 3);
    StoreScoped(index 15);
    Pop(count 1);
    LoadScoped(index 16);
    Literal(lit 13);
    BinOp(op '*');
    LoadVar(index 3);
    StoreScoped(index 16);
    Pop(count 1);
    LoadScoped(index 14);
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 0, count 2);
    Pop(count 1);
    LoadScoped(index 15);
    Literal(lit 17);
    BinOp(op '*');
    LoadVar(index 3);
    StoreScoped(index 15);
    Pop(count 1);
    LoadScoped(index 16);
    Literal(lit 17);
    BinOp(op '*');
    LoadVar(index 3);
    StoreScoped(index 16);
    Pop(count 1);
    Literal(lit undefined);
    AsyncReturn();
}

function nestedFunc1() {
  entry:
    AsyncStart(count 3, flag false);
    LoadArg(index 0);
    StoreScoped(index 2);
    Literal(lit 5);
    AsyncReturn();
}

function nestedFunc2() {
  entry:
    AsyncStart(count 3, flag false);
    LoadArg(index 0);
    StoreScoped(index 2);
    Literal(lit 7);
    AsyncReturn();
}

function nestedFunc3() {
  entry:
    AsyncStart(count 7, flag false);
    LoadArg(index 0);
    StoreScoped(index 2);
    LoadArg(index 1);
    StoreScoped(index 3);
    LoadArg(index 2);
    StoreScoped(index 4);
    LoadArg(index 3);
    StoreScoped(index 5);
    LoadArg(index 4);
    StoreScoped(index 6);
    LoadScoped(index 3);
    LoadScoped(index 4);
    BinOp(op '+');
    LoadScoped(index 5);
    BinOp(op '+');
    LoadScoped(index 6);
    BinOp(op '+');
    AsyncReturn();
}

function nestedFunc4() {
  entry:
    AsyncStart(count 7, flag true);
    LoadArg(index 0);
    StoreScoped(index 2);
    LoadArg(index 1);
    StoreScoped(index 3);
    LoadArg(index 2);
    StoreScoped(index 4);
    LoadArg(index 3);
    StoreScoped(index 5);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 3);
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 4);
    Literal(lit 5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 5);
    Literal(lit 7);
    Call(count 3, flag true);
    LoadScoped(index 13);
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 0, count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 3);
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 4);
    Literal(lit 5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 5);
    Literal(lit 7);
    Call(count 3, flag true);
    Literal(lit undefined);
    AsyncReturn();
}

function nestedFunc5() {
  entry:
    AsyncStart(count 3, flag false);
    LoadArg(index 0);
    StoreScoped(index 2);
    Literal(lit undefined);
    AsyncReturn();
}

function nestedFunc6() {
  entry:
    AsyncStart(count 5, flag true);
    LoadArg(index 0);
    StoreScoped(index 2);
    LoadArg(index 1);
    StoreScoped(index 3);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 2);
    Literal(lit 'a');
    ObjectGet();
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 2);
    Literal(lit 'b');
    ObjectGet();
    Literal(lit 5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 3);
    Literal(lit 7);
    Call(count 3, flag true);
    LoadScoped(index 12);
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 0, count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 2);
    Literal(lit 'a');
    ObjectGet();
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 2);
    Literal(lit 'b');
    ObjectGet();
    Literal(lit 5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 3);
    Literal(lit 7);
    Call(count 3, flag true);
    Literal(lit undefined);
    AsyncReturn();
}

function nestedFunc7() {
  entry:
    AsyncStart(count 3, flag false);
    LoadArg(index 0);
    StoreScoped(index 2);
    Literal(lit undefined);
    AsyncReturn();
}

function run() {
  entry:
    // Void-call async function
    LoadGlobal(name 'runAsync');
    Literal(lit undefined);
    Call(count 1, flag true);
    Literal(lit undefined);
    Return();
}

function runAsync() {
  entry:
    AsyncStart(count 5, flag false);
    LoadArg(index 0);
    StoreScoped(index 4);
    StartTry(@block1);
    LoadGlobal(name 'test_minimal');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'test_awaitReturnValue');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'test_asyncVariablesFromNested');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'test_asyncInExpression');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'test_asyncFunctionArguments');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'test_asyncThisArgument');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'global:asyncTestComplete');
    Literal(lit undefined);
    Literal(lit true);
    Literal(lit undefined);
    Call(count 3, flag true);
    EndTry();
    Jump(@block2);
  block1:
    LoadGlobal(name 'global:asyncTestComplete');
    Literal(lit undefined);
    Literal(lit false);
    LoadVar(index 3);
    Call(count 3, flag true);
    Pop(count 1);
    Jump(@block2);
  block2:
    Literal(lit undefined);
    AsyncReturn();
}

function test_asyncFunctionArguments() {
  entry:
    AsyncStart(count 5, flag false);
    LoadArg(index 0);
    StoreScoped(index 3);
    Literal(lit &function nestedFunc4);
    ClosureNew();
    Literal(lit &function nestedFunc5);
    StoreScoped(index 4);
    // This function tests that function arguments are correctly captured by
    // async functions.
    LoadVar(index 3);
    Literal(lit undefined);
    Literal(lit 3);
    Literal(lit 5);
    Literal(lit 7);
    AwaitCall(count 4);
    Await();
    AsyncResume(count 1, count 3);
    Pop(count 1);
    Pop(count 1);
    Literal(lit undefined);
    AsyncReturn();
}

function test_asyncInExpression() {
  entry:
    AsyncStart(count 12, flag false);
    LoadArg(index 0);
    StoreScoped(index 11);
    Literal(lit &function nestedFunc1);
    Literal(lit &function nestedFunc2);
    Literal(lit &function nestedFunc3);
    Literal(lit deleted);
    Literal(lit deleted);
    // Here the array literal is a temporary pushed to the stack and then each
    // element is awaited in turn. This tests that the temporary is correctly
    // restored after each await point.
    ArrayNew();
    LoadVar(index 8);
    Literal(lit 0);
    Literal(lit 3);
    ObjectSet();
    LoadVar(index 8);
    Literal(lit 1);
    LoadVar(index 3);
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 8, count 10);
    ObjectSet();
    LoadVar(index 8);
    Literal(lit 2);
    LoadVar(index 4);
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 8, count 10);
    ObjectSet();
    LoadVar(index 8);
    Literal(lit 3);
    Literal(lit 11);
    ObjectSet();
    StoreVar(index 6);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 6);
    Literal(lit 'length');
    ObjectGet();
    Literal(lit 4);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 6);
    Literal(lit 0);
    ObjectGet();
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 6);
    Literal(lit 1);
    ObjectGet();
    Literal(lit 5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 6);
    Literal(lit 2);
    ObjectGet();
    Literal(lit 7);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 6);
    Literal(lit 3);
    ObjectGet();
    Literal(lit 11);
    Call(count 3, flag true);
    // Similarly here the function call involves pushing the arguments to the
    // stack as temporaries, so this tests that the stack is correctly restored
    // after each await point.
    LoadVar(index 5);
    Literal(lit undefined);
    Literal(lit 3);
    LoadVar(index 3);
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 8, count 10);
    LoadVar(index 4);
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 9, count 11);
    Literal(lit 11);
    AwaitCall(count 5);
    Await();
    AsyncResume(count 5, count 7);
    StoreVar(index 7);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 7);
    Literal(lit 26);
    Call(count 3, flag true);
    Pop(count 5);
    Literal(lit undefined);
    AsyncReturn();
}

function test_asyncThisArgument() {
  entry:
    AsyncStart(count 6, flag false);
    LoadArg(index 0);
    StoreScoped(index 4);
    Literal(lit &function nestedFunc6);
    ClosureNew();
    Literal(lit &function nestedFunc7);
    StoreScoped(index 5);
    Literal(lit deleted);
    ObjectNew();
    LoadVar(index 5);
    Literal(lit 'a');
    Literal(lit 3);
    ObjectSet();
    LoadVar(index 5);
    Literal(lit 'b');
    Literal(lit 5);
    ObjectSet();
    LoadVar(index 5);
    Literal(lit 'nestedFunc');
    LoadVar(index 3);
    ObjectSet();
    StoreVar(index 4);
    // This function tests that function arguments are correctly captured by
    // async functions.
    Literal(lit undefined);
    LoadVar(index 4);
    LoadVar(index 6);
    Literal(lit 'nestedFunc');
    ObjectGet();
    StoreVar(index 5);
    Literal(lit 7);
    AwaitCall(count 2);
    Await();
    AsyncResume(count 2, count 4);
    Pop(count 1);
    Pop(count 2);
    Literal(lit undefined);
    AsyncReturn();
}

function test_asyncVariablesFromNested() {
  entry:
    AsyncStart(count 11, flag false);
    LoadArg(index 0);
    StoreScoped(index 7);
    Literal(lit &function nested2);
    ClosureNew();
    StoreScoped(index 8);
    Literal(lit deleted);
    // This function tests that variables in an async function can be accessed
    // correctly from a nested closure.
    // Variable in root
    Literal(lit 2);
    StoreScoped(index 9);
    // closure-accessed
    Literal(lit 3);
    StoreVar(index 3);
    // local-accessed
    StartTry(@block3);
    Literal(lit &function nestedFunc);
    ClosureNew();
    Literal(lit deleted);
    // Variable nested in try block.
    Literal(lit 5);
    StoreScoped(index 10);
    // closure-accessed
    Literal(lit 7);
    StoreVar(index 7);
    // local accessed
    LoadVar(index 6);
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 5, count 4);
    Pop(count 1);
    LoadScoped(index 9);
    Literal(lit 11);
    BinOp(op '*');
    LoadVar(index 8);
    StoreScoped(index 9);
    Pop(count 1);
    LoadScoped(index 10);
    Literal(lit 11);
    BinOp(op '*');
    LoadVar(index 8);
    StoreScoped(index 10);
    Pop(count 1);
    LoadVar(index 3);
    Literal(lit 11);
    BinOp(op '*');
    LoadVar(index 8);
    StoreVar(index 3);
    Pop(count 1);
    LoadVar(index 7);
    Literal(lit 11);
    BinOp(op '*');
    LoadVar(index 8);
    StoreVar(index 7);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 10);
    Literal(lit 12155);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 7);
    Literal(lit 77);
    Call(count 3, flag true);
    EndTry();
    Jump(@block4);
  block3:
    Pop(count 1);
    Literal(lit 0);
    LoadVar(index 4);
    StoreScoped(index 9);
    Pop(count 1);
    Literal(lit 0);
    LoadVar(index 4);
    StoreVar(index 3);
    Pop(count 1);
    Jump(@block4);
  block4:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 9);
    Literal(lit 92378);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 3);
    Literal(lit 33);
    Call(count 3, flag true);
    Pop(count 1);
    Literal(lit undefined);
    AsyncReturn();
}

// Tests awaiting a JS async function which completes immediately with a return
// value. This tests basic await-call and that the return value is used
// correctly. Also the result is scheduled on the job queue.
function test_awaitReturnValue() {
  entry:
    AsyncStart(count 5, flag false);
    LoadArg(index 0);
    StoreScoped(index 4);
    Literal(lit &function asyncFunction);
    Literal(lit deleted);
    LoadVar(index 3);
    Literal(lit undefined);
    Literal(lit 22);
    AwaitCall(count 2);
    Await();
    AsyncResume(count 2, count 4);
    StoreVar(index 4);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 4);
    Literal(lit 23);
    Call(count 3, flag true);
    Pop(count 2);
    Literal(lit undefined);
    AsyncReturn();
}

// Void-calling async function with no await points or variable bindings.
function test_minimal() {
  entry:
    Literal(lit &function myAsyncFunc);
    LoadGlobal(name 'global:print');
    Literal(lit undefined);
    Literal(lit 'Before async function');
    Call(count 2, flag true);
    // Void-calling async func. It will complete synchronously and the promise
    // will be elided because it's not used.
    LoadVar(index 0);
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'global:print');
    Literal(lit undefined);
    Literal(lit 'After async synchronous return');
    Call(count 2, flag true);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

allocation 5 = {
  push: &function Array_push,
};