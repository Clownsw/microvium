[this module slot] 'thisModule'
[free var] 'vmExport'
[free var] 'asyncTestComplete'
[free var] 'undefined'
[free var] 'print'
[free var] 'assertEqual'
[global slot] 'thisModule'
[global slot] 'runAsync'
[global slot] 'test_minimal'
[global slot] 'test_awaitReturnValue'
[global slot] 'test_asyncVariablesFromNested'
[global slot] 'test_asyncInExpression'
[global slot] 'test_asyncFunctionArguments'
[global slot] 'test_asyncThisArgument'

module with entry 'moduleEntry' {
  [no closure scope]; [0 var declarations]

  bindings {
    function 'run' # binding_1 @ local[0];
    function 'runAsync' # binding_2 @ global['runAsync'];
    function 'test_minimal' # binding_3 @ global['test_minimal'];
    function 'test_awaitReturnValue' # binding_4 @ global['test_awaitReturnValue'];
    function 'test_asyncVariablesFromNested' # binding_5 @ global['test_asyncVariablesFromNested'];
    function 'test_asyncInExpression' # binding_6 @ global['test_asyncInExpression'];
    function 'test_asyncFunctionArguments' # binding_7 @ global['test_asyncFunctionArguments'];
    function 'test_asyncThisArgument' # binding_8 @ global['test_asyncThisArgument']
  }

  references { vmExport @ free vmExport; run @ binding_1 }

  prologue {
    func 'run' -> local[0]
    func 'runAsync' -> global['runAsync']
    func 'test_minimal' -> global['test_minimal']
    func 'test_awaitReturnValue' -> global['test_awaitReturnValue']
    func 'test_asyncVariablesFromNested' -> global['test_asyncVariablesFromNested']
    func 'test_asyncInExpression' -> global['test_asyncInExpression']
    func 'test_asyncFunctionArguments' -> global['test_asyncFunctionArguments']
    func 'test_asyncThisArgument' -> global['test_asyncThisArgument']
  }

  function run as 'run' {
    [no closure scope]; [0 var declarations]

    bindings { this '#this' # binding_9 @ arg[0] }

    No references

    prologue {  }

    block {
      sameInstanceCountAsParent: true; [no closure scope]

      bindings {  }

      prologue {  }

      epilogue {  }

      references { runAsync @ binding_2 }
    }
  }

  function runAsync as 'runAsync' {
    [closure scope with 3 slots: async-continuation, async-callback, this]
    [0 var declarations]

    bindings { this '#this' # binding_10 @ scoped[!2] }

    No references

    prologue {
      AsyncStart(3, false); arg[0] as this -> scoped[+2]
    }

    block {
      sameInstanceCountAsParent: true; [no closure scope]

      bindings {  }

      prologue {  }

      epilogue {  }

      No references

      block {
        sameInstanceCountAsParent: true; [no closure scope]

        bindings {  }

        prologue { StartTry }

        epilogue { !EndTry }

        references {
          test_minimal @ binding_3
          test_awaitReturnValue @ binding_4
          test_asyncVariablesFromNested @ binding_5
          test_asyncInExpression @ binding_6
          test_asyncFunctionArguments @ binding_7
          test_asyncThisArgument @ binding_8
          asyncTestComplete @ free asyncTestComplete
          undefined @ free undefined
        }
      }

      block {
        sameInstanceCountAsParent: true; [no closure scope]

        bindings { catch-param 'e' # binding_11 @ local[3] }

        prologue { Stack has exception }

        epilogue { Pop(1) }

        references {
          asyncTestComplete @ free asyncTestComplete
          e @ binding_11
        }
      }
    }
  }

  function test_minimal as 'test_minimal' {
    [no closure scope]; [0 var declarations]

    bindings { this '#this' # binding_12 @ arg[0] }

    No references

    prologue {  }

    block {
      sameInstanceCountAsParent: true; [no closure scope]

      bindings {
        function 'myAsyncFunc' # binding_13 @ local[0]
      }

      prologue { func 'myAsyncFunc' -> local[0] }

      epilogue { Pop(1) }

      references {
        print @ free print
        myAsyncFunc @ binding_13
        print @ free print
      }

      function myAsyncFunc as 'myAsyncFunc' {
        [closure scope with 3 slots: async-continuation, async-callback, this]
        [0 var declarations]

        bindings { this '#this' # binding_14 @ scoped[!2] }

        No references

        prologue {
          AsyncStart(3, false); arg[0] as this -> scoped[+2]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          references { print @ free print }
        }
      }
    }
  }

  function test_awaitReturnValue as 'test_awaitReturnValue' {
    [closure scope with 3 slots: async-continuation, async-callback, this]
    [0 var declarations]

    bindings { this '#this' # binding_15 @ scoped[!2] }

    No references

    prologue {
      AsyncStart(3, false); arg[0] as this -> scoped[+2]
    }

    block {
      sameInstanceCountAsParent: true; [no closure scope]

      bindings {
        readonly const 'result' # binding_16 @ local[4];
        function 'asyncFunction' # binding_17 @ local[3]
      }

      prologue {
        func 'asyncFunction' -> local[3]
        new let -> local[4]
      }

      epilogue { Pop(2) }

      references {
        asyncFunction @ binding_17
        assertEqual @ free assertEqual
        result @ binding_16
      }

      function asyncFunction as 'asyncFunction' {
        [closure scope with 4 slots: async-continuation, async-callback, this, arg]
        [0 var declarations]

        bindings {
          this '#this' # binding_18 @ scoped[!2];
          param 'arg' # binding_19 @ scoped[!3]
        }

        No references

        prologue {
          AsyncStart(4, false)
          arg[0] as this -> scoped[+2]
          arg[1] -> scoped[+3]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          references {
            arg @ binding_19 using relative slot index 3
          }
        }
      }
    }
  }

  function test_asyncVariablesFromNested as 'test_asyncVariablesFromNested' {
    [closure scope with 6 slots: async-continuation,
    async-callback,
    this,
    nested2,
    x1,
    y1]
    [0 var declarations]

    bindings { this '#this' # binding_20 @ scoped[!2] }

    No references

    prologue {
      AsyncStart(6, false); arg[0] as this -> scoped[+2]
    }

    block {
      sameInstanceCountAsParent: true; [no closure scope]

      bindings {
        writable let 'x1' # binding_21 @ scoped[!4];
        writable let 'x2' # binding_22 @ local[3];
        function 'nested2' # binding_23 @ scoped[!3]
      }

      prologue {
        func 'nested2' -> scoped[+3] [non-embedded closure]
        new let -> local[3]
      }

      epilogue { Pop(1) }

      references {
        assertEqual @ free assertEqual
        x1 @ binding_21 using relative slot index 4
        assertEqual @ free assertEqual
        x2 @ binding_22
      }

      block {
        sameInstanceCountAsParent: true; [no closure scope]

        bindings {
          writable let 'y1' # binding_24 @ scoped[!5];
          writable let 'y2' # binding_25 @ local[7];
          function 'nestedFunc' # binding_26 @ local[6]
        }

        prologue {
          StartTry
          func 'nestedFunc' -> local[6] [non-embedded closure]
          new let -> local[7]
        }

        epilogue { !EndTry }

        references {
          nestedFunc @ binding_26
          x1 @ binding_21 using relative slot index 4
          y1 @ binding_24 using relative slot index 5
          x2 @ binding_22
          y2 @ binding_25
          assertEqual @ free assertEqual
          y1 @ binding_24 using relative slot index 5
          assertEqual @ free assertEqual
          y2 @ binding_25
        }

        closure function nestedFunc as 'nestedFunc' {
          [closure scope with 4 slots: async-continuation,
          async-callback,
          this,
          parent-reference]
          [0 var declarations]

          bindings {
            this '#this' # binding_27 @ scoped[!2]
          }

          No references

          prologue {
            AsyncStart(4, true)
            arg[0] as this -> scoped[+2]
          }

          block {
            sameInstanceCountAsParent: true
            [no closure scope]

            bindings {  }

            prologue {  }

            epilogue {  }

            references {
              x1 @ binding_21 using relative slot index 10
              y1 @ binding_24 using relative slot index 11
              nested2 @ binding_23 using relative slot index 9
              x1 @ binding_21 using relative slot index 10
              y1 @ binding_24 using relative slot index 11
            }
          }
        }
      }

      block {
        sameInstanceCountAsParent: true; [no closure scope]

        bindings {  }

        prologue { Stack has exception; Pop exception }

        epilogue {  }

        references {
          x1 @ binding_21 using relative slot index 4
          x2 @ binding_22
        }
      }

      closure function nested2 as 'nested2' {
        [closure scope with 4 slots: async-continuation,
        async-callback,
        this,
        parent-reference]
        [0 var declarations]

        bindings { this '#this' # binding_28 @ scoped[!2] }

        No references

        prologue {
          AsyncStart(4, true); arg[0] as this -> scoped[+2]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          references {
            x1 @ binding_21 using relative slot index 10
          }
        }
      }
    }
  }

  function test_asyncInExpression as 'test_asyncInExpression' {
    [closure scope with 3 slots: async-continuation, async-callback, this]
    [0 var declarations]

    bindings { this '#this' # binding_29 @ scoped[!2] }

    No references

    prologue {
      AsyncStart(3, false); arg[0] as this -> scoped[+2]
    }

    block {
      sameInstanceCountAsParent: true; [no closure scope]

      bindings {
        readonly const 'x' # binding_30 @ local[6];
        readonly const 'y' # binding_31 @ local[7];
        function 'nestedFunc' # binding_32 @ local[3];
        function 'nestedFunc2' # binding_33 @ local[4];
        function 'nestedFunc3' # binding_34 @ local[5]
      }

      prologue {
        func 'nestedFunc1' -> local[3]
        func 'nestedFunc2' -> local[4]
        func 'nestedFunc3' -> local[5]
        new let -> local[6]
        new let -> local[7]
      }

      epilogue { Pop(5) }

      references {
        nestedFunc @ binding_32
        nestedFunc2 @ binding_33
        assertEqual @ free assertEqual
        x @ binding_30
        assertEqual @ free assertEqual
        x @ binding_30
        assertEqual @ free assertEqual
        x @ binding_30
        assertEqual @ free assertEqual
        x @ binding_30
        assertEqual @ free assertEqual
        x @ binding_30
        nestedFunc3 @ binding_34
        nestedFunc @ binding_32
        nestedFunc2 @ binding_33
        assertEqual @ free assertEqual
        y @ binding_31
      }

      function nestedFunc as 'nestedFunc1' {
        [closure scope with 3 slots: async-continuation, async-callback, this]
        [0 var declarations]

        bindings { this '#this' # binding_35 @ scoped[!2] }

        No references

        prologue {
          AsyncStart(3, false); arg[0] as this -> scoped[+2]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          No references
        }
      }

      function nestedFunc2 as 'nestedFunc2' {
        [closure scope with 3 slots: async-continuation, async-callback, this]
        [0 var declarations]

        bindings { this '#this' # binding_36 @ scoped[!2] }

        No references

        prologue {
          AsyncStart(3, false); arg[0] as this -> scoped[+2]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          No references
        }
      }

      function nestedFunc3 as 'nestedFunc3' {
        [closure scope with 7 slots: async-continuation, async-callback, this, a, b, c, d]
        [0 var declarations]

        bindings {
          this '#this' # binding_37 @ scoped[!2];
          param 'a' # binding_38 @ scoped[!3];
          param 'b' # binding_39 @ scoped[!4];
          param 'c' # binding_40 @ scoped[!5];
          param 'd' # binding_41 @ scoped[!6]
        }

        No references

        prologue {
          AsyncStart(7, false)
          arg[0] as this -> scoped[+2]
          arg[1] -> scoped[+3]
          arg[2] -> scoped[+4]
          arg[3] -> scoped[+5]
          arg[4] -> scoped[+6]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          references {
            a @ binding_38 using relative slot index 3
            b @ binding_39 using relative slot index 4
            c @ binding_40 using relative slot index 5
            d @ binding_41 using relative slot index 6
          }
        }
      }
    }
  }

  function test_asyncFunctionArguments as 'test_asyncFunctionArguments' {
    [closure scope with 4 slots: async-continuation, async-callback, this, nestedFunc2]
    [0 var declarations]

    bindings { this '#this' # binding_42 @ scoped[!2] }

    No references

    prologue {
      AsyncStart(4, false); arg[0] as this -> scoped[+2]
    }

    block {
      sameInstanceCountAsParent: true; [no closure scope]

      bindings {
        function 'nestedFunc' # binding_43 @ local[3];
        function 'nestedFunc2' # binding_44 @ scoped[!3]
      }

      prologue {
        func 'nestedFunc4' -> local[3] [non-embedded closure]
        func 'nestedFunc5' -> scoped[+3]
      }

      epilogue { Pop(1) }

      references { nestedFunc @ binding_43 }

      closure function nestedFunc as 'nestedFunc4' {
        [closure scope with 7 slots: async-continuation,
        async-callback,
        this,
        a,
        b,
        c,
        parent-reference]
        [0 var declarations]

        bindings {
          this '#this' # binding_45 @ scoped[!2];
          param 'a' # binding_46 @ scoped[!3];
          param 'b' # binding_47 @ scoped[!4];
          param 'c' # binding_48 @ scoped[!5]
        }

        No references

        prologue {
          AsyncStart(7, true)
          arg[0] as this -> scoped[+2]
          arg[1] -> scoped[+3]
          arg[2] -> scoped[+4]
          arg[3] -> scoped[+5]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          references {
            assertEqual @ free assertEqual
            a @ binding_46 using relative slot index 3
            assertEqual @ free assertEqual
            b @ binding_47 using relative slot index 4
            assertEqual @ free assertEqual
            c @ binding_48 using relative slot index 5
            nestedFunc2 @ binding_44 using relative slot index 12
            assertEqual @ free assertEqual
            a @ binding_46 using relative slot index 3
            assertEqual @ free assertEqual
            b @ binding_47 using relative slot index 4
            assertEqual @ free assertEqual
            c @ binding_48 using relative slot index 5
          }
        }
      }

      function nestedFunc2 as 'nestedFunc5' {
        [closure scope with 3 slots: async-continuation, async-callback, this]
        [0 var declarations]

        bindings { this '#this' # binding_49 @ scoped[!2] }

        No references

        prologue {
          AsyncStart(3, false); arg[0] as this -> scoped[+2]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          No references
        }
      }
    }
  }

  function test_asyncThisArgument as 'test_asyncThisArgument' {
    [closure scope with 4 slots: async-continuation, async-callback, this, nestedFunc2]
    [0 var declarations]

    bindings { this '#this' # binding_50 @ scoped[!2] }

    No references

    prologue {
      AsyncStart(4, false); arg[0] as this -> scoped[+2]
    }

    block {
      sameInstanceCountAsParent: true; [no closure scope]

      bindings {
        readonly const 'obj' # binding_51 @ local[4];
        function 'nestedFunc' # binding_52 @ local[3];
        function 'nestedFunc2' # binding_53 @ scoped[!3]
      }

      prologue {
        func 'nestedFunc6' -> local[3] [non-embedded closure]
        func 'nestedFunc7' -> scoped[+3]
        new let -> local[4]
      }

      epilogue { Pop(2) }

      references {
        nestedFunc @ binding_52; obj @ binding_51
      }

      closure function nestedFunc as 'nestedFunc6' {
        [closure scope with 5 slots: async-continuation,
        async-callback,
        this,
        c,
        parent-reference]
        [0 var declarations]

        bindings {
          this '#this' # binding_54 @ scoped[!2];
          param 'c' # binding_55 @ scoped[!3]
        }

        No references

        prologue {
          AsyncStart(5, true)
          arg[0] as this -> scoped[+2]
          arg[1] -> scoped[+3]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          references {
            assertEqual @ free assertEqual
            '#this' @ binding_54 using relative slot index 2
            assertEqual @ free assertEqual
            '#this' @ binding_54 using relative slot index 2
            assertEqual @ free assertEqual
            c @ binding_55 using relative slot index 3
            nestedFunc2 @ binding_53 using relative slot index 10
            assertEqual @ free assertEqual
            '#this' @ binding_54 using relative slot index 2
            assertEqual @ free assertEqual
            '#this' @ binding_54 using relative slot index 2
            assertEqual @ free assertEqual
            c @ binding_55 using relative slot index 3
          }
        }
      }

      function nestedFunc2 as 'nestedFunc7' {
        [closure scope with 3 slots: async-continuation, async-callback, this]
        [0 var declarations]

        bindings { this '#this' # binding_56 @ scoped[!2] }

        No references

        prologue {
          AsyncStart(3, false); arg[0] as this -> scoped[+2]
        }

        block {
          sameInstanceCountAsParent: true
          [no closure scope]

          bindings {  }

          prologue {  }

          epilogue {  }

          No references
        }
      }
    }
  }
}