export 0 = &function run;

slot Error = class (&function Error, &allocation 10);
slot ['global:Promise'] = class (&function promiseConstructor, &allocation 2);
slot ['global:Reflect'] = &allocation 3;
slot ['global:assert'] = host function 2;
slot ['global:assertEqual'] = host function 3;
slot ['global:asyncTestComplete'] = host function 6;
slot myAsyncFunc = &function myAsyncFunc;
slot myAsyncFuncReject = &function myAsyncFuncReject;
slot runAsync = &function runAsync;
slot test_asyncReturnsPromise = &function test_asyncReturnsPromise;
slot test_awaitMustBeAsynchronous = &function test_awaitMustBeAsynchronous;
slot test_promiseAwait = &function test_promiseAwait;
slot test_promiseAwaitReject = &function test_promiseAwaitReject;
slot test_promiseConstructor = &function test_promiseConstructor;
slot test_promiseKeys = &function test_promiseKeys;

function Error() {
  entry:
    LoadArg(index 1);
    LoadArg(index 0);
    Literal(lit 'message');
    LoadVar(index 0);
    ObjectSet();
    Pop(count 1);
    LoadArg(index 0);
    Return();
}

function ['Reflect.ownKeys']() {
  entry:
    LoadArg(index 1);
    ObjectKeys();
    Return();
}

function anonymous() {
  entry:
    LoadArg(index 1);
    Literal(lit undefined);
    Literal(lit 42);
    Call(count 2, flag true);
    Literal(lit undefined);
    Return();
}

function asyncCatchBlock() {
  entry:
    Literal(lit false);
    AsyncComplete();
}

function asyncContinue() {
  entry:
    LoadScoped(index 1);
    Literal(lit undefined);
    LoadScoped(index 2);
    LoadScoped(index 3);
    Call(count 3, flag false);
    Return();
}

function asyncHostCallback() {
  entry:
    Literal(lit undefined);
    LoadArg(index 2);
    LoadArg(index 1);
    AsyncComplete();
}

function inner() {
  entry:
    AsyncStart(count 4, flag true);
    Literal(lit deleted);
    LoadGlobal(name 'myAsyncFunc');
    Literal(lit undefined);
    Call(count 1, flag false);
    StoreVar(index 3);
    LoadScoped(index 10);
    Literal(lit '; Before await');
    BinOp(op '+');
    LoadVar(index 4);
    StoreScoped(index 10);
    Pop(count 1);
    LoadVar(index 3);
    Await();
    AsyncResume(count 1, count 3);
    Pop(count 1);
    LoadScoped(index 10);
    Literal(lit '; After await');
    BinOp(op '+');
    LoadVar(index 4);
    StoreScoped(index 10);
    Pop(count 1);
    Pop(count 1);
    Literal(lit undefined);
    AsyncReturn();
}

function myAsyncFunc() {
  entry:
    AsyncStart(count 2, flag false);
    Literal(lit 42);
    AsyncReturn();
}

function myAsyncFuncReject() {
  entry:
    AsyncStart(count 2, flag false);
    LoadGlobal(name 'Error');
    Literal(lit undefined);
    Literal(lit '42');
    New(count 2);
    Throw();
}

function promiseConstructor() {
  entry:
    LoadArg(index 1);
    Literal(lit undefined);
    ScopeNew(count 2);
    Literal(lit &function promiseResolve);
    StoreScoped(index 0);
    LoadArg(index 0);
    StoreScoped(index 1);
    ScopeSave();
    ScopeNew(count 2);
    Literal(lit &function promiseReject);
    StoreScoped(index 0);
    LoadArg(index 0);
    StoreScoped(index 1);
    ScopeSave();
    Call(count 3, flag true);
    LoadArg(index 0);
    Return();
}

function promiseReject() {
  entry:
    Literal(lit undefined);
    LoadArg(index 1);
    Literal(lit false);
    AsyncComplete();
}

function promiseResolve() {
  entry:
    Literal(lit undefined);
    LoadArg(index 1);
    Literal(lit true);
    AsyncComplete();
}

function run() {
  entry:
    // Void-call async function
    LoadGlobal(name 'runAsync');
    Literal(lit undefined);
    Call(count 1, flag true);
    Literal(lit undefined);
    Return();
}

function runAsync() {
  entry:
    AsyncStart(count 4, flag false);
    StartTry(@block1);
    LoadGlobal(name 'test_asyncReturnsPromise');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'test_promiseKeys');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'test_promiseAwait');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'test_promiseAwaitReject');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'test_awaitMustBeAsynchronous');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'test_promiseConstructor');
    Literal(lit undefined);
    AwaitCall(count 1);
    Await();
    AsyncResume(count 2, count 2);
    Pop(count 1);
    LoadGlobal(name 'global:asyncTestComplete');
    Literal(lit undefined);
    Literal(lit true);
    Literal(lit undefined);
    Call(count 3, flag true);
    EndTry();
    Jump(@block2);
  block1:
    LoadGlobal(name 'global:asyncTestComplete');
    Literal(lit undefined);
    Literal(lit false);
    LoadVar(index 3);
    Call(count 3, flag true);
    Pop(count 1);
    Jump(@block2);
  block2:
    Literal(lit undefined);
    AsyncReturn();
}

function test_asyncReturnsPromise() {
  entry:
    Literal(lit deleted);
    LoadGlobal(name 'myAsyncFunc');
    Literal(lit undefined);
    Call(count 1, flag false);
    StoreVar(index 0);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit '__proto__');
    ObjectGet();
    LoadGlobal(name 'global:Promise');
    Literal(lit 'prototype');
    ObjectGet();
    BinOp(op '===');
    Call(count 2, flag true);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function test_awaitMustBeAsynchronous() {
  entry:
    AsyncStart(count 5, flag false);
    Literal(lit &function inner);
    ClosureNew();
    Literal(lit deleted);
    Literal(lit 'Start');
    StoreScoped(index 4);
    LoadVar(index 3);
    Literal(lit undefined);
    Call(count 1, flag false);
    StoreVar(index 4);
    // No await - should not block
    LoadScoped(index 4);
    Literal(lit '; After inner()');
    BinOp(op '+');
    LoadVar(index 5);
    StoreScoped(index 4);
    Pop(count 1);
    LoadVar(index 4);
    Await();
    AsyncResume(count 2, count 4);
    Pop(count 1);
    // The key here is that "After inner" should come before "After await",
    // because even though myAsyncFunc resolves immediately, the continuation
    // should be scheduled asynchronously.
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadScoped(index 4);
    Literal(lit 'Start; Before await; After inner(); After await');
    Call(count 3, flag true);
    Pop(count 2);
    Literal(lit undefined);
    AsyncReturn();
}

function test_promiseAwait() {
  entry:
    AsyncStart(count 4, flag false);
    Literal(lit deleted);
    Literal(lit deleted);
    LoadGlobal(name 'myAsyncFunc');
    Literal(lit undefined);
    Call(count 1, flag false);
    StoreVar(index 3);
    LoadVar(index 3);
    Await();
    AsyncResume(count 2, count 4);
    StoreVar(index 4);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 4);
    Literal(lit 42);
    Call(count 3, flag true);
    Pop(count 2);
    Literal(lit undefined);
    AsyncReturn();
}

function test_promiseAwaitReject() {
  entry:
    AsyncStart(count 5, flag false);
    Literal(lit deleted);
    LoadGlobal(name 'myAsyncFuncReject');
    Literal(lit undefined);
    Call(count 1, flag false);
    StoreVar(index 3);
    StartTry(@block3);
    LoadVar(index 3);
    Await();
    AsyncResume(count 3, count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit false);
    Literal(lit 'promise should have rejected');
    Call(count 3, flag true);
    EndTry();
    Jump(@block4);
  block3:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 4);
    Literal(lit 'message');
    ObjectGet();
    Literal(lit '42');
    Call(count 3, flag true);
    Pop(count 1);
    Jump(@block4);
  block4:
    Pop(count 1);
    Literal(lit undefined);
    AsyncReturn();
}

function test_promiseConstructor() {
  entry:
    AsyncStart(count 4, flag false);
    Literal(lit deleted);
    Literal(lit deleted);
    LoadGlobal(name 'global:Promise');
    Literal(lit undefined);
    Literal(lit &function anonymous);
    New(count 2);
    StoreVar(index 3);
    LoadVar(index 3);
    Await();
    AsyncResume(count 2, count 4);
    StoreVar(index 4);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 4);
    Literal(lit 42);
    Call(count 3, flag true);
    Pop(count 2);
    Literal(lit undefined);
    AsyncReturn();
}

function test_promiseKeys() {
  entry:
    AsyncStart(count 2, flag false);
    Literal(lit deleted);
    Literal(lit deleted);
    Literal(lit deleted);
    LoadGlobal(name 'myAsyncFunc');
    Literal(lit undefined);
    Call(count 1, flag false);
    StoreVar(index 3);
    Literal(lit undefined);
    LoadGlobal(name 'global:Reflect');
    LoadVar(index 7);
    Literal(lit 'ownKeys');
    ObjectGet();
    StoreVar(index 6);
    LoadVar(index 3);
    Call(count 2, flag false);
    StoreVar(index 4);
    // Even though the promise has 2 internal slots, which occupy the first
    // key-value pair slot, it should still have no own properties since the
    // the key used for internal slots is not a valid property key.
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 4);
    Literal(lit 'length');
    ObjectGet();
    Literal(lit 0);
    Call(count 3, flag true);
    // Reflect.ownKeys is ignoring the internal slots but should not ignore the
    // properties that follow the internal slots
    Literal(lit 5);
    LoadVar(index 3);
    Literal(lit 'prop');
    LoadVar(index 6);
    ObjectSet();
    Pop(count 1);
    Literal(lit undefined);
    LoadGlobal(name 'global:Reflect');
    LoadVar(index 7);
    Literal(lit 'ownKeys');
    ObjectGet();
    StoreVar(index 6);
    LoadVar(index 3);
    Call(count 2, flag false);
    StoreVar(index 5);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 5);
    Literal(lit 'length');
    ObjectGet();
    Literal(lit 1);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 5);
    Literal(lit 0);
    ObjectGet();
    Literal(lit 'prop');
    Call(count 3, flag true);
    Pop(count 3);
    Literal(lit undefined);
    AsyncReturn();
}

allocation 1 = {
};

allocation 10 = {
  prototype: &allocation 11,
};

allocation 11 = {
};

allocation 2 = {
  prototype: &allocation 1,
};

allocation 3 = {
  ownKeys: &function ['Reflect.ownKeys'],
};