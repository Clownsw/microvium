unit ['./test/end-to-end/tests/number-operations.test.mvm.js'];

entry ['#entry'];

external vmExport;
external assertEqual;
external Infinity;
external overflowChecks;
external assert;
external Number;
external NaN;

global thisModule;
global testNegate;
global testUnaryPlus;
global testAddition;
global testSubtraction;
global testMultiplication;
global testDivision;
global testLessThan;
global testGreaterThan;
global testRemainder;
global testPower;
global testIncrDecr;

function ['#entry']() {
  entry:
    LoadArg(index 0);
    StoreGlobal(name 'thisModule');
    Literal(lit &function run);
    Literal(lit &function testNegate);
    StoreGlobal(name 'testNegate');
    Literal(lit &function testUnaryPlus);
    StoreGlobal(name 'testUnaryPlus');
    Literal(lit &function testAddition);
    StoreGlobal(name 'testAddition');
    Literal(lit &function testSubtraction);
    StoreGlobal(name 'testSubtraction');
    Literal(lit &function testMultiplication);
    StoreGlobal(name 'testMultiplication');
    Literal(lit &function testDivision);
    StoreGlobal(name 'testDivision');
    Literal(lit &function testLessThan);
    StoreGlobal(name 'testLessThan');
    Literal(lit &function testGreaterThan);
    StoreGlobal(name 'testGreaterThan');
    Literal(lit &function testRemainder);
    StoreGlobal(name 'testRemainder');
    Literal(lit &function testPower);
    StoreGlobal(name 'testPower');
    Literal(lit &function testIncrDecr);
    StoreGlobal(name 'testIncrDecr');
    // ---
    // description: >
    // Tests various operations that should classify as vm_TeNumberOp operations
    // runExportedFunction: 0
    // assertionCount: 122
    // ---
    LoadGlobal(name 'vmExport');
    Literal(lit undefined);
    Literal(lit 0);
    LoadVar(index 0);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function run() {
  entry:
    LoadGlobal(name 'testNegate');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testUnaryPlus');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testAddition');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testSubtraction');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testMultiplication');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testDivision');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testLessThan');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testGreaterThan');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testRemainder');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testPower');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testIncrDecr');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testNegate() {
  entry:
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit 2);
    Literal(lit 3);
    BinOp(op '-');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'Infinity');
    UnOp(op '-');
    Literal(lit -1.1);
    Literal(lit 0);
    BinOp(op '/');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2147483648);
    UnOp(op '-');
    LoadGlobal(name 'overflowChecks');
    Branch(@block1, @block2);
  block1:
    Literal(lit 2147483648);
    Jump(@block3);
  block2:
    Literal(lit -2147483648);
    Jump(@block3);
  block3:
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testUnaryPlus() {
  entry:
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 1);
    BinOp(op '+');
    UnOp(op '+');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2);
    BinOp(op '+');
    UnOp(op '+');
    Literal(lit 3.1);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testAddition() {
  entry:
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 3);
    Literal(lit 2);
    BinOp(op '+');
    Literal(lit 5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 2000);
    BinOp(op '+');
    Literal(lit 5000);
    Call(count 3);
    Pop(count 1);
    // out of 8 bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 3500);
    BinOp(op '+');
    Literal(lit 6500);
    Call(count 3);
    Pop(count 1);
    // 12 bit addition (should not overflow, but should take the fast path still)
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 6000);
    Literal(lit 500);
    BinOp(op '+');
    Literal(lit 6500);
    Call(count 3);
    Pop(count 1);
    // 13 bit addition. Does not technically overflow but should take the slow path
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 500);
    Literal(lit 6500);
    BinOp(op '+');
    Literal(lit 7000);
    Call(count 3);
    Pop(count 1);
    // 13 bit addition. Does not technically overflow but should take the slow path
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 10000);
    Literal(lit 8000);
    BinOp(op '+');
    Literal(lit 18000);
    Call(count 3);
    Pop(count 1);
    // out of 14 bit signed range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 80000);
    Literal(lit 70000);
    BinOp(op '+');
    Literal(lit 150000);
    Call(count 3);
    Pop(count 1);
    // out of 16 bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 7500);
    Literal(lit 7000);
    BinOp(op '+');
    Literal(lit 14500);
    Call(count 3);
    Pop(count 1);
    // overflow 14-bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2000000000);
    Literal(lit 2000000000);
    BinOp(op '+');
    LoadGlobal(name 'overflowChecks');
    Branch(@block4, @block5);
  block4:
    Literal(lit 4000000000);
    Jump(@block6);
  block5:
    Literal(lit -294967296);
    Jump(@block6);
  block6:
    Call(count 3);
    Pop(count 1);
    // underflow signed 32-bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -1.5);
    Literal(lit 1);
    BinOp(op '+');
    Literal(lit -0.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit 0.5);
    BinOp(op '+');
    Literal(lit -1.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -5000000000);
    Literal(lit 4999999000);
    BinOp(op '+');
    Literal(lit -1000);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testSubtraction() {
  entry:
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 3);
    Literal(lit 2);
    BinOp(op '-');
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 2000);
    BinOp(op '-');
    Literal(lit 1000);
    Call(count 3);
    Pop(count 1);
    // out of 8 bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 10000);
    Literal(lit 8000);
    BinOp(op '-');
    Literal(lit 2000);
    Call(count 3);
    Pop(count 1);
    // out of 14 bit signed range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 80000);
    Literal(lit 70000);
    BinOp(op '-');
    Literal(lit 10000);
    Call(count 3);
    Pop(count 1);
    // out of 16 bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -7500);
    Literal(lit 7000);
    BinOp(op '-');
    Literal(lit -14500);
    Call(count 3);
    Pop(count 1);
    // underflow 14-bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2000000000);
    Literal(lit 2000000000);
    BinOp(op '-');
    LoadGlobal(name 'overflowChecks');
    Branch(@block7, @block8);
  block7:
    Literal(lit -4000000000);
    Jump(@block9);
  block8:
    Literal(lit 294967296);
    Jump(@block9);
  block9:
    Call(count 3);
    Pop(count 1);
    // underflow signed 32-bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1.5);
    Literal(lit 1);
    BinOp(op '-');
    Literal(lit 0.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 0.5);
    BinOp(op '-');
    Literal(lit 1.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 5000000000);
    Literal(lit 4999999000);
    BinOp(op '-');
    Literal(lit 1000);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testMultiplication() {
  entry:
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit 6);
    BinOp(op '*');
    Literal(lit 30);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 5.5);
    Literal(lit 6);
    BinOp(op '*');
    Literal(lit 33);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -5);
    Literal(lit -6);
    BinOp(op '*');
    Literal(lit 30);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit -6);
    BinOp(op '*');
    Literal(lit -30);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 5000);
    Literal(lit 5000);
    BinOp(op '*');
    Literal(lit 25000000);
    Call(count 3);
    Pop(count 1);
    // Overflow 14-bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 17000);
    Literal(lit 2);
    BinOp(op '*');
    Literal(lit 34000);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 5000000);
    Literal(lit 5000000);
    BinOp(op '*');
    LoadGlobal(name 'overflowChecks');
    Branch(@block10, @block11);
  block10:
    Literal(lit 25000000000000);
    Jump(@block12);
  block11:
    Literal(lit -1004630016);
    Jump(@block12);
  block12:
    Call(count 3);
    Pop(count 1);
    // Overflow 32-bit range
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 25000000000000);
    Literal(lit 1);
    BinOp(op '*');
    Literal(lit 25000000000000);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testDivision() {
  entry:
    // Floating point division (the normal)
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 6);
    Literal(lit 3);
    BinOp(op '/');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 7);
    Literal(lit 2);
    BinOp(op '/');
    Literal(lit 3.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 8.5);
    Literal(lit 2.5);
    BinOp(op '/');
    Literal(lit 3.4);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 0);
    BinOp(op '/');
    LoadGlobal(name 'Infinity');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -0);
    BinOp(op '/');
    LoadGlobal(name 'Infinity');
    UnOp(op '-');
    Call(count 3);
    Pop(count 1);
    // Without overflow checks enabled, the negation of integer zero is integer zero
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 1);
    Literal(lit 1);
    BinOp(op '-');
    UnOp(op '-');
    BinOp(op '/');
    LoadGlobal(name 'overflowChecks');
    Branch(@block13, @block14);
  block13:
    LoadGlobal(name 'Infinity');
    UnOp(op '-');
    Jump(@block15);
  block14:
    LoadGlobal(name 'Infinity');
    Jump(@block15);
  block15:
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 0);
    BinOp(op '/');
    LoadGlobal(name 'Infinity');
    UnOp(op '-');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -0);
    BinOp(op '/');
    LoadGlobal(name 'Infinity');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assert');
    Literal(lit undefined);
    LoadGlobal(name 'Number');
    LoadVar(index 2);
    Literal(lit 'isNaN');
    ObjectGet();
    LoadVar(index 2);
    LoadGlobal(name 'Infinity');
    LoadGlobal(name 'Infinity');
    BinOp(op '/');
    Call(count 2);
    StoreVar(index 2);
    Call(count 2);
    Pop(count 1);
    // Integer division
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 6);
    Literal(lit 3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 7);
    Literal(lit 2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 8.5);
    Literal(lit 2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -6);
    Literal(lit -3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -7);
    Literal(lit -2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -8.5);
    Literal(lit -2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -6);
    Literal(lit 3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -7);
    Literal(lit 2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -8.5);
    Literal(lit 2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'NaN');
    LoadGlobal(name 'NaN');
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'Infinity');
    LoadGlobal(name 'Infinity');
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testLessThan() {
  entry:
    // Integers
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Integers
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testGreaterThan() {
  entry:
    // Integers
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Integers
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testRemainder() {
  entry:
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '%');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit 2);
    BinOp(op '%');
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 550);
    Literal(lit 100);
    BinOp(op '%');
    Literal(lit 50);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 3);
    BinOp(op '%');
    Literal(lit -2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -3);
    BinOp(op '%');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -3);
    BinOp(op '%');
    Literal(lit -2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.25);
    Literal(lit 1);
    BinOp(op '%');
    Literal(lit 0.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 5.25);
    Literal(lit 2);
    BinOp(op '%');
    Literal(lit 1.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 550.25);
    Literal(lit 100);
    BinOp(op '%');
    Literal(lit 50.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -7.25);
    Literal(lit 4);
    BinOp(op '%');
    Literal(lit -3.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 7.25);
    Literal(lit -4);
    BinOp(op '%');
    Literal(lit 3.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit -7.25);
    Literal(lit -4);
    BinOp(op '%');
    Literal(lit -3.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assert');
    Literal(lit undefined);
    LoadGlobal(name 'Number');
    LoadVar(index 2);
    Literal(lit 'isNaN');
    ObjectGet();
    LoadVar(index 2);
    Literal(lit 5);
    Literal(lit 0);
    BinOp(op '%');
    Call(count 2);
    StoreVar(index 2);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'assert');
    Literal(lit undefined);
    LoadGlobal(name 'Number');
    LoadVar(index 2);
    Literal(lit 'isNaN');
    ObjectGet();
    LoadVar(index 2);
    Literal(lit 5.1);
    Literal(lit 0);
    BinOp(op '%');
    Call(count 2);
    StoreVar(index 2);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testPower() {
  entry:
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 3);
    BinOp(op '**');
    Literal(lit 8);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 0);
    BinOp(op '**');
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    Literal(lit 2.5);
    Literal(lit 1);
    BinOp(op '**');
    Literal(lit 2.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assert');
    Literal(lit undefined);
    LoadGlobal(name 'Number');
    LoadVar(index 2);
    Literal(lit 'isNaN');
    ObjectGet();
    LoadVar(index 2);
    Literal(lit 1);
    LoadGlobal(name 'Infinity');
    BinOp(op '**');
    Call(count 2);
    StoreVar(index 2);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testIncrDecr() {
  entry:
    Literal(lit deleted);
    Literal(lit 1);
    StoreVar(index 0);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    LoadVar(index 3);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 4);
    StoreVar(index 0);
    Pop(count 1);
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    LoadVar(index 3);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 4);
    StoreVar(index 0);
    Pop(count 1);
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    Literal(lit 1.5);
    LoadVar(index 1);
    StoreVar(index 0);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 2.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 1.5);
    Call(count 3);
    Pop(count 1);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}