export 0 = &function ['./test/end-to-end/tests/number-operations.test.mvms:run'];

slot ['./test/end-to-end/tests/number-operations.test.mvms:testAddition'] = &function ['./test/end-to-end/tests/number-operations.test.mvms:testAddition'];
slot ['./test/end-to-end/tests/number-operations.test.mvms:testDivision'] = &function ['./test/end-to-end/tests/number-operations.test.mvms:testDivision'];
slot ['./test/end-to-end/tests/number-operations.test.mvms:testGreaterThan'] = &function ['./test/end-to-end/tests/number-operations.test.mvms:testGreaterThan'];
slot ['./test/end-to-end/tests/number-operations.test.mvms:testLessThan'] = &function ['./test/end-to-end/tests/number-operations.test.mvms:testLessThan'];
slot ['./test/end-to-end/tests/number-operations.test.mvms:testMultiplication'] = &function ['./test/end-to-end/tests/number-operations.test.mvms:testMultiplication'];
slot ['./test/end-to-end/tests/number-operations.test.mvms:testNegate'] = &function ['./test/end-to-end/tests/number-operations.test.mvms:testNegate'];
slot ['./test/end-to-end/tests/number-operations.test.mvms:testSubtraction'] = &function ['./test/end-to-end/tests/number-operations.test.mvms:testSubtraction'];
slot ['./test/end-to-end/tests/number-operations.test.mvms:testUnaryPlus'] = &function ['./test/end-to-end/tests/number-operations.test.mvms:testUnaryPlus'];
slot ['global:Infinity'] = Infinity;
slot ['global:NaN'] = NaN;
slot ['global:assert'] = host function 2;
slot ['global:assertEqual'] = host function 3;
slot ['global:isNaN'] = host function 65533;
slot ['global:overflowChecks'] = false;
slot ['global:print'] = host function 1;
slot ['global:undefined'] = undefined;
slot ['global:vmExport'] = &ephemeral vmExport;

function ['./test/end-to-end/tests/number-operations.test.mvms:run']() {
  entry:
    LoadGlobal(name './test/end-to-end/tests/number-operations.test.mvms:testNegate');
    Call(count 0);
    Pop(count 1);
    LoadGlobal(name './test/end-to-end/tests/number-operations.test.mvms:testUnaryPlus');
    Call(count 0);
    Pop(count 1);
    LoadGlobal(name './test/end-to-end/tests/number-operations.test.mvms:testAddition');
    Call(count 0);
    Pop(count 1);
    LoadGlobal(name './test/end-to-end/tests/number-operations.test.mvms:testSubtraction');
    Call(count 0);
    Pop(count 1);
    LoadGlobal(name './test/end-to-end/tests/number-operations.test.mvms:testMultiplication');
    Call(count 0);
    Pop(count 1);
    LoadGlobal(name './test/end-to-end/tests/number-operations.test.mvms:testDivision');
    Call(count 0);
    Pop(count 1);
    LoadGlobal(name './test/end-to-end/tests/number-operations.test.mvms:testLessThan');
    Call(count 0);
    Pop(count 1);
    LoadGlobal(name './test/end-to-end/tests/number-operations.test.mvms:testGreaterThan');
    Call(count 0);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['./test/end-to-end/tests/number-operations.test.mvms:testAddition']() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 3);
    Literal(lit 2);
    BinOp(op '+');
    Literal(lit 5);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 3000);
    Literal(lit 2000);
    BinOp(op '+');
    Literal(lit 5000);
    Call(count 2);
    Pop(count 1);
    // out of 8 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 3000);
    Literal(lit 3500);
    BinOp(op '+');
    Literal(lit 6500);
    Call(count 2);
    Pop(count 1);
    // 12 bit addition (should not overflow, but should take the fast path still)
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 6000);
    Literal(lit 500);
    BinOp(op '+');
    Literal(lit 6500);
    Call(count 2);
    Pop(count 1);
    // 13 bit addition. Does not technically overflow but should take the slow path
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 500);
    Literal(lit 6500);
    BinOp(op '+');
    Literal(lit 7000);
    Call(count 2);
    Pop(count 1);
    // 13 bit addition. Does not technically overflow but should take the slow path
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 10000);
    Literal(lit 8000);
    BinOp(op '+');
    Literal(lit 18000);
    Call(count 2);
    Pop(count 1);
    // out of 14 bit signed range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 80000);
    Literal(lit 70000);
    BinOp(op '+');
    Literal(lit 150000);
    Call(count 2);
    Pop(count 1);
    // out of 16 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 7500);
    Literal(lit 7000);
    BinOp(op '+');
    Literal(lit 14500);
    Call(count 2);
    Pop(count 1);
    // overflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2000000000);
    Literal(lit 2000000000);
    BinOp(op '+');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block1, @block2);
  block1:
    Literal(lit 4000000000);
    Jump(@block3);
  block2:
    Literal(lit -294967296);
    Jump(@block3);
  block3:
    Call(count 2);
    Pop(count 1);
    // underflow signed 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -1.5);
    Literal(lit 1);
    BinOp(op '+');
    Literal(lit -0.5);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit 0.5);
    BinOp(op '+');
    Literal(lit -1.5);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -5000000000);
    Literal(lit 4999999000);
    BinOp(op '+');
    Literal(lit -1000);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['./test/end-to-end/tests/number-operations.test.mvms:testDivision']() {
  entry:
    // Floating point division (the normal)
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 6);
    Literal(lit 3);
    BinOp(op '/');
    Literal(lit 2);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 7);
    Literal(lit 2);
    BinOp(op '/');
    Literal(lit 3.5);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 8.5);
    Literal(lit 2.5);
    BinOp(op '/');
    Literal(lit 3.4);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 8);
    Literal(lit 0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 8);
    Literal(lit -0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Call(count 2);
    Pop(count 1);
    // Without overflow checks enabled, the negation of integer zero is integer zero
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 8);
    Literal(lit 1);
    Literal(lit 1);
    BinOp(op '-');
    UnOp(op '-');
    BinOp(op '/');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block1, @block2);
  block1:
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Jump(@block3);
  block2:
    LoadGlobal(name 'global:Infinity');
    Jump(@block3);
  block3:
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -8);
    Literal(lit 0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -8);
    Literal(lit -0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assert');
    LoadGlobal(name 'global:isNaN');
    LoadGlobal(name 'global:Infinity');
    LoadGlobal(name 'global:Infinity');
    BinOp(op '/');
    Call(count 1);
    Call(count 1);
    Pop(count 1);
    // Integer division
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 6);
    Literal(lit 3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 2);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 7);
    Literal(lit 2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 8.5);
    Literal(lit 2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -6);
    Literal(lit -3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 2);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -7);
    Literal(lit -2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -8.5);
    Literal(lit -2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -6);
    Literal(lit 3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -2);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -7);
    Literal(lit 2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -3);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -8.5);
    Literal(lit 2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -3);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 8);
    Literal(lit 0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 8);
    Literal(lit -0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -8);
    Literal(lit 0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -8);
    Literal(lit -0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    LoadGlobal(name 'global:NaN');
    LoadGlobal(name 'global:NaN');
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    LoadGlobal(name 'global:Infinity');
    LoadGlobal(name 'global:Infinity');
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['./test/end-to-end/tests/number-operations.test.mvms:testGreaterThan']() {
  entry:
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '>');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '>');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '>');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['./test/end-to-end/tests/number-operations.test.mvms:testLessThan']() {
  entry:
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '<');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '<');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '<');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['./test/end-to-end/tests/number-operations.test.mvms:testMultiplication']() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 5);
    Literal(lit 6);
    BinOp(op '*');
    Literal(lit 30);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 5.5);
    Literal(lit 6);
    BinOp(op '*');
    Literal(lit 33);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -5);
    Literal(lit -6);
    BinOp(op '*');
    Literal(lit 30);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 5);
    Literal(lit -6);
    BinOp(op '*');
    Literal(lit -30);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 5000);
    Literal(lit 5000);
    BinOp(op '*');
    Literal(lit 25000000);
    Call(count 2);
    Pop(count 1);
    // Overflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 17000);
    Literal(lit 2);
    BinOp(op '*');
    Literal(lit 34000);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 5000000);
    Literal(lit 5000000);
    BinOp(op '*');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block1, @block2);
  block1:
    Literal(lit 25000000000000);
    Jump(@block3);
  block2:
    Literal(lit -1004630016);
    Jump(@block3);
  block3:
    Call(count 2);
    Pop(count 1);
    // Overflow 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 25000000000000);
    Literal(lit 1);
    BinOp(op '*');
    Literal(lit 25000000000000);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['./test/end-to-end/tests/number-operations.test.mvms:testNegate']() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -1);
    Literal(lit 2);
    Literal(lit 3);
    BinOp(op '-');
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Literal(lit -1.1);
    Literal(lit 0);
    BinOp(op '/');
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2147483648);
    UnOp(op '-');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block1, @block2);
  block1:
    Literal(lit 2147483648);
    Jump(@block3);
  block2:
    Literal(lit -2147483648);
    Jump(@block3);
  block3:
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['./test/end-to-end/tests/number-operations.test.mvms:testSubtraction']() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 3);
    Literal(lit 2);
    BinOp(op '-');
    Literal(lit 1);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 3000);
    Literal(lit 2000);
    BinOp(op '-');
    Literal(lit 1000);
    Call(count 2);
    Pop(count 1);
    // out of 8 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 10000);
    Literal(lit 8000);
    BinOp(op '-');
    Literal(lit 2000);
    Call(count 2);
    Pop(count 1);
    // out of 14 bit signed range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 80000);
    Literal(lit 70000);
    BinOp(op '-');
    Literal(lit 10000);
    Call(count 2);
    Pop(count 1);
    // out of 16 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -7500);
    Literal(lit 7000);
    BinOp(op '-');
    Literal(lit -14500);
    Call(count 2);
    Pop(count 1);
    // underflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit -2000000000);
    Literal(lit 2000000000);
    BinOp(op '-');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block1, @block2);
  block1:
    Literal(lit -4000000000);
    Jump(@block3);
  block2:
    Literal(lit 294967296);
    Jump(@block3);
  block3:
    Call(count 2);
    Pop(count 1);
    // underflow signed 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1.5);
    Literal(lit 1);
    BinOp(op '-');
    Literal(lit 0.5);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 2);
    Literal(lit 0.5);
    BinOp(op '-');
    Literal(lit 1.5);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 5000000000);
    Literal(lit 4999999000);
    BinOp(op '-');
    Literal(lit 1000);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function ['./test/end-to-end/tests/number-operations.test.mvms:testUnaryPlus']() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1);
    Literal(lit 1);
    BinOp(op '+');
    UnOp(op '+');
    Literal(lit 2);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit 1.1);
    Literal(lit 2);
    BinOp(op '+');
    UnOp(op '+');
    Literal(lit 3.1);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

allocation 1 = {
};