#pragma once

#include "stdint.h"

#define MVM_BYTECODE_VERSION 2

typedef struct mvm_Builtins {
  uint16_t arrayProtoPointer;
  /** Pointer to additional unique strings table in GC memory. Note that when a
   * snapshot is generated by the comprehensive VM (i.e. the first time it's
   * generated), this can just be null since all strings are in the string
   * table. This field is only needed on devices that need to generate a
   * snapshot after adding more unique strings, but don't have the power to
   * regenerate the string table or the corresponding bytecode layout. */
  uint16_t uniqueStringsRAMPointer;
} mvm_Builtins;

typedef struct mvm_TsBytecodeHeader {
  // WIP: While we're making changes to the bytecode version, considering
  // removing all the `*Size` fields and instead rely on them being in order, so
  // that the size can be inferred based on the position of the next section.
  // I'm thinking it would make sense to have an enumeration rather than a
  // struct, so the size of a section can generically be calculated by
  // subtracting two adjacent offsets. The READ_BC_HEADER macro can probably be
  // changed to "readSectionSize" and "readSectionOffset". Likewise, it would
  // make sense if the builtins used an enumeration.
  uint8_t bytecodeVersion; // MVM_BYTECODE_VERSION
  uint8_t headerSize;
  uint16_t bytecodeSize; // Including header
  uint16_t crc; // CCITT16 (header and data, of everything after the CRC)
  uint16_t requiredEngineVersion;
  uint32_t requiredFeatureFlags;
  mvm_Builtins builtins;
  uint16_t globalVariableCount;
  uint16_t gcRootsOffset; // Points to a table of pointers to GC roots in data memory (to use in addition to the global variables as roots)
  uint16_t gcRootsCount;
  uint16_t importTableOffset; // vm_TsImportTableEntry
  uint16_t importTableSize;
  uint16_t exportTableOffset; // vm_TsExportTableEntry
  uint16_t exportTableSize;
  uint16_t shortCallTableOffset; // vm_TsShortCallTableEntry
  uint16_t shortCallTableSize;
  uint16_t stringTableOffset; // Alphabetical index of UNIQUED_STRING values. Each element is a bytecode offset (WIP: this is new) (TODO: Check these are always generated at 2-byte alignment)
  uint16_t stringTableSize;
  uint16_t initialDataOffset; // Note: the initial-data section MUST be second-last in the bytecode file
  uint16_t initialDataSize;
  uint16_t initialHeapOffset; // Note: the initial heap MUST be the last thing in the bytecode file, since it's the only thing that changes size from one snapshot to the next on the native VM.
  uint16_t initialHeapSize;
} mvm_TsBytecodeHeader;

typedef enum mvm_TeFeatureFlags {
  FF_FLOAT_SUPPORT = 0,
} mvm_TeFeatureFlags;
